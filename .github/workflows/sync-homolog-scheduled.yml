name: Sync Homolog - Deploy AutomÃ¡tico Agendado

# Executa a cada 3 horas
on:
  schedule:
    # Cron: a cada 3 horas (00:00, 03:00, 06:00, 09:00, 12:00, 15:00, 18:00, 21:00)
    - cron: '0 */3 * * *'
  workflow_dispatch: # Permite execuÃ§Ã£o manual

jobs:
  sync-homolog:
    name: Sincronizar Integration â†’ Homolog
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: Checkout do cÃ³digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configurar Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Verificar se branch homolog existe
        id: check_branches
        run: |
          # Verificar se branch homolog existe remotamente
          if git ls-remote --heads origin homolog | grep -q homolog; then
            echo "homolog_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Branch homolog existe"
          else
            echo "homolog_exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  Branch homolog nÃ£o existe, serÃ¡ criada"
          fi
          
          # Verificar se branch integration existe
          if git ls-remote --heads origin integration | grep -q integration; then
            echo "integration_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Branch integration existe"
          else
            echo "integration_exists=false" >> $GITHUB_OUTPUT
            echo "âŒ Branch integration nÃ£o existe!"
            exit 1
          fi

      - name: Fazer checkout das branches
        run: |
          git fetch origin homolog integration
          
          # Criar branch homolog localmente se nÃ£o existir
          if [ "${{ steps.check_branches.outputs.homolog_exists }}" = "false" ]; then
            git checkout -b homolog origin/integration || git checkout -b homolog
            echo "Branch homolog criada a partir de integration"
          else
            git checkout homolog
            git pull origin homolog
          fi
          
          # Fazer checkout de integration para comparaÃ§Ã£o
          git fetch origin integration

      - name: Calcular delta entre homolog e integration
        id: calculate_delta
        run: |
          # Verificar se hÃ¡ diferenÃ§as entre homolog e integration
          if git diff --quiet homolog origin/integration; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "âœ… NÃ£o hÃ¡ diferenÃ§as entre homolog e integration"
            echo "Nenhum deploy necessÃ¡rio"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "ðŸ“‹ HÃ¡ diferenÃ§as entre homolog e integration"
            
            # Listar arquivos modificados
            CHANGED_FILES=$(git diff --name-only homolog origin/integration | head -20)
            echo "Arquivos modificados:"
            echo "$CHANGED_FILES"
            
            # Contar commits
            COMMIT_COUNT=$(git rev-list --count homolog..origin/integration)
            echo "Commits a serem deployados: $COMMIT_COUNT"
            echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: Sair se nÃ£o houver mudanÃ§as
        if: steps.calculate_delta.outputs.has_changes != 'true'
        run: |
          echo "âœ… Nenhuma mudanÃ§a detectada. SincronizaÃ§Ã£o nÃ£o necessÃ¡ria."
          exit 0

      - name: Instalar jq
        if: steps.calculate_delta.outputs.has_changes == 'true'
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Configurar SFDX CLI
        if: steps.calculate_delta.outputs.has_changes == 'true'
        uses: salesforce/setup-sfdx@v1

      - name: Autenticar na org de Homolog
        if: steps.calculate_delta.outputs.has_changes == 'true'
        env:
          SF_USERNAME: ${{ secrets.SF_USERNAME_HOMOLOG }}
          SF_PASSWORD: ${{ secrets.SF_PASSWORD_HOMOLOG }}
          SF_SECURITY_TOKEN: ${{ secrets.SF_SECURITY_TOKEN_HOMOLOG }}
          SF_LOGIN_URL: ${{ secrets.SF_LOGIN_URL_HOMOLOG }}
        run: |
          echo "ðŸ” Autenticando na org de homolog..."
          echo "y" | sf org login web --alias homolog-sync --instance-url $SF_LOGIN_URL --set-default

      - name: Preparar arquivos para deploy (delta)
        if: steps.calculate_delta.outputs.has_changes == 'true'
        id: prepare_deploy
        run: |
          # Criar diretÃ³rio temporÃ¡rio com apenas os arquivos modificados
          DELTA_DIR=$(mktemp -d)
          echo "delta_dir=$DELTA_DIR" >> $GITHUB_OUTPUT
          
          # Obter lista de arquivos modificados
          CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRT homolog origin/integration)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "âš ï¸  Nenhum arquivo modificado detectado"
            exit 1
          fi
          
          # Criar estrutura de diretÃ³rios e copiar arquivos
          echo "$CHANGED_FILES" | while read -r file; do
            if [ -f "$file" ] && [[ "$file" == force-app/* ]]; then
              # Criar estrutura de diretÃ³rios
              mkdir -p "$DELTA_DIR/$(dirname "$file")"
              # Copiar arquivo
              cp "$file" "$DELTA_DIR/$file"
            fi
          done
          
          # Fazer checkout dos arquivos da branch integration
          git checkout origin/integration -- $CHANGED_FILES
          
          echo "ðŸ“¦ Arquivos preparados para deploy"
          echo "Total de arquivos: $(echo "$CHANGED_FILES" | wc -l)"

      - name: Executar deploy na org de Homolog
        if: steps.calculate_delta.outputs.has_changes == 'true'
        id: deploy
        continue-on-error: true
        run: |
          echo "ðŸš€ Iniciando deploy na org de homolog..."
          
          # Executar deploy e capturar output
          set +e
          DEPLOY_OUTPUT=$(sf project deploy start \
            --source-dir force-app \
            --target-org homolog-sync \
            --ignore-warnings \
            --wait 10 \
            --json 2>&1)
          DEPLOY_EXIT_CODE=$?
          set -e
          
          # Salvar output em arquivo
          echo "$DEPLOY_OUTPUT" > deploy-output.json
          
          # Tentar extrair JSON vÃ¡lido
          JSON_OUTPUT=$(echo "$DEPLOY_OUTPUT" | grep -o '{.*}' | tail -1 || echo "")
          
          if [ -z "$JSON_OUTPUT" ]; then
            echo "deploy_success=false" >> $GITHUB_OUTPUT
            echo "deploy_error<<EOF" >> $GITHUB_OUTPUT
            echo "Erro ao executar deploy. Output:" >> $GITHUB_OUTPUT
            echo "$DEPLOY_OUTPUT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Verificar status do deploy
          STATUS=$(echo "$JSON_OUTPUT" | jq -r '.status // 1' 2>/dev/null || echo "1")
          SUCCESS=$(echo "$JSON_OUTPUT" | jq -r '.result.success // false' 2>/dev/null || echo "false")
          
          if [ "$STATUS" = "0" ] && [ "$SUCCESS" = "true" ]; then
            echo "âœ… Deploy realizado com sucesso!"
            echo "deploy_success=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Deploy falhou"
            echo "deploy_success=false" >> $GITHUB_OUTPUT
            
            # Extrair erros
            ERROR_MESSAGES=$(echo "$JSON_OUTPUT" | jq -r '.result.details.componentFailures[]? | "\(.fileName):\(.lineNumber) - \(.problem)"' 2>/dev/null || echo "")
            
            if [ -z "$ERROR_MESSAGES" ]; then
              ERROR_MESSAGES=$(echo "$JSON_OUTPUT" | jq -r '.message // .result.message // "Erro desconhecido no deploy"' 2>/dev/null || echo "Erro desconhecido no deploy")
            fi
            
            echo "deploy_error<<EOF" >> $GITHUB_OUTPUT
            echo "$ERROR_MESSAGES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            # Salvar output completo
            echo "deploy_output<<EOF" >> $GITHUB_OUTPUT
            echo "$JSON_OUTPUT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Salvar log de erro do deploy
        if: steps.deploy.outputs.deploy_success != 'true'
        run: |
          echo "ðŸ’¾ Salvando log de erro do deploy..."
          
          # Garantir que estamos na branch homolog
          git checkout homolog
          git pull origin homolog || true
          
          # Criar diretÃ³rio de logs se nÃ£o existir
          mkdir -p logs/deploy-errors
          
          # Criar nome do arquivo com timestamp
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          LOG_FILE="logs/deploy-errors/deploy-error-${TIMESTAMP}.log"
          
          # Obter informaÃ§Ãµes do commit
          INTEGRATION_COMMIT=$(git rev-parse origin/integration 2>/dev/null || echo "N/A")
          CHANGED_FILES=$(git diff --name-only homolog origin/integration 2>/dev/null || echo "N/A")
          COMMITS=$(git log --oneline homolog..origin/integration 2>/dev/null || echo "N/A")
          
          # Criar conteÃºdo do log
          cat > "$LOG_FILE" << EOF
# Log de Erro de Deploy - SincronizaÃ§Ã£o AutomÃ¡tica Homolog
# Data: $(date)
# Branch: integration â†’ homolog
# Workflow Run: ${{ github.run_id }}
# Commit Integration: $INTEGRATION_COMMIT

## Erros do Deploy

${{ steps.deploy.outputs.deploy_error }}

## Output Completo

${{ steps.deploy.outputs.deploy_output }}

## Arquivos Modificados

$CHANGED_FILES

## Commits

$COMMITS
EOF
          
          # Adicionar e commitar o log
          git add "$LOG_FILE"
          
          if git diff --staged --quiet; then
            echo "âš ï¸  Nenhuma mudanÃ§a para commitar"
          else
            git commit -m "chore: adicionar log de erro de deploy [skip ci]" || true
            git push origin homolog || echo "âš ï¸  NÃ£o foi possÃ­vel fazer push do log"
            echo "âœ… Log commitado e enviado para branch homolog"
          fi
          
          echo "ðŸ“„ Log salvo em: $LOG_FILE"

      - name: Fazer merge para homolog (se deploy foi bem-sucedido)
        if: steps.deploy.outputs.deploy_success == 'true'
        run: |
          echo "ðŸ”„ Fazendo merge de integration para homolog..."
          
          # Garantir que estamos na branch homolog
          git checkout homolog
          git pull origin homolog || true
          
          # Fazer merge de integration
          git merge origin/integration --no-edit -m "chore: merge automÃ¡tico de integration para homolog [skip ci]"
          
          # Push para homolog
          git push origin homolog
          
          echo "âœ… Merge realizado com sucesso!"
          echo "Branch homolog atualizada com as alteraÃ§Ãµes de integration"

      - name: Criar resumo da execuÃ§Ã£o
        if: always()
        run: |
          echo "## ðŸ“Š Resumo da SincronizaÃ§Ã£o" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Data/Hora**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch Origem**: integration" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch Destino**: homolog" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.calculate_delta.outputs.has_changes }}" = "true" ]; then
            echo "- **Commits**: ${{ steps.calculate_delta.outputs.commit_count }}" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ steps.deploy.outputs.deploy_success }}" = "true" ]; then
              echo "- **Status**: âœ… Deploy realizado com sucesso e merge concluÃ­do" >> $GITHUB_STEP_SUMMARY
            else
              echo "- **Status**: âŒ Deploy falhou - log de erro salvo" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "- **Status**: â„¹ï¸  Nenhuma mudanÃ§a detectada" >> $GITHUB_STEP_SUMMARY
          fi
