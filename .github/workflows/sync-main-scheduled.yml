name: Sync Main - Deploy AutomÃ¡tico Agendado (ProduÃ§Ã£o)

# Executa a cada 3 horas
on:
  schedule:
    # Cron: a cada 3 horas (00:00, 03:00, 06:00, 09:00, 12:00, 15:00, 18:00, 21:00)
    - cron: '0 */3 * * *'
  workflow_dispatch: # Permite execuÃ§Ã£o manual

jobs:
  sync-main:
    name: Sincronizar StepMaster â†’ Main (ProduÃ§Ã£o)
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: Checkout do cÃ³digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configurar Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Verificar se branch main existe
        id: check_branches
        run: |
          # Verificar se branch main existe remotamente
          if git ls-remote --heads origin main | grep -q main; then
            echo "main_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Branch main existe"
          else
            echo "main_exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  Branch main nÃ£o existe, serÃ¡ criada"
          fi
          
          # Verificar se branch StepMaster existe
          if git ls-remote --heads origin StepMaster | grep -q StepMaster; then
            echo "stepmaster_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Branch StepMaster existe"
          else
            echo "stepmaster_exists=false" >> $GITHUB_OUTPUT
            echo "âŒ Branch StepMaster nÃ£o existe!"
            exit 1
          fi

      - name: Fazer checkout das branches
        run: |
          git fetch origin main StepMaster
          
          # Criar branch main localmente se nÃ£o existir
          if [ "${{ steps.check_branches.outputs.main_exists }}" = "false" ]; then
            git checkout -b main origin/StepMaster || git checkout -b main
            echo "Branch main criada a partir de StepMaster"
          else
            git checkout main
            git pull origin main
          fi
          
          # Fazer checkout de StepMaster para comparaÃ§Ã£o
          git fetch origin StepMaster

      - name: Calcular delta entre main e StepMaster
        id: calculate_delta
        run: |
          # Verificar se hÃ¡ diferenÃ§as entre main e StepMaster
          if git diff --quiet main origin/StepMaster; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "âœ… NÃ£o hÃ¡ diferenÃ§as entre main e StepMaster"
            echo "Nenhum deploy necessÃ¡rio"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "ðŸ“‹ HÃ¡ diferenÃ§as entre main e StepMaster"
            
            # Listar arquivos modificados
            CHANGED_FILES=$(git diff --name-only main origin/StepMaster | head -20)
            echo "Arquivos modificados:"
            echo "$CHANGED_FILES"
            
            # Contar commits
            COMMIT_COUNT=$(git rev-list --count main..origin/StepMaster)
            echo "Commits a serem deployados: $COMMIT_COUNT"
            echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: Sair se nÃ£o houver mudanÃ§as
        if: steps.calculate_delta.outputs.has_changes != 'true'
        run: |
          echo "âœ… Nenhuma mudanÃ§a detectada. SincronizaÃ§Ã£o nÃ£o necessÃ¡ria."
          exit 0

      - name: Instalar jq
        if: steps.calculate_delta.outputs.has_changes == 'true'
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Configurar SFDX CLI
        if: steps.calculate_delta.outputs.has_changes == 'true'
        uses: salesforce/setup-sfdx@v1

      - name: Autenticar na org de ProduÃ§Ã£o
        if: steps.calculate_delta.outputs.has_changes == 'true'
        env:
          SF_USERNAME: ${{ secrets.SF_USERNAME_PROD }}
          SF_PASSWORD: ${{ secrets.SF_PASSWORD_PROD }}
          SF_SECURITY_TOKEN: ${{ secrets.SF_SECURITY_TOKEN_PROD }}
          SF_LOGIN_URL: ${{ secrets.SF_LOGIN_URL_PROD }}
        run: |
          echo "ðŸ” Autenticando na org de produÃ§Ã£o..."
          echo "y" | sf org login web --alias prod-sync --instance-url $SF_LOGIN_URL --set-default

      - name: Preparar arquivos para deploy (delta)
        if: steps.calculate_delta.outputs.has_changes == 'true'
        id: prepare_deploy
        run: |
          # Criar diretÃ³rio temporÃ¡rio com apenas os arquivos modificados
          DELTA_DIR=$(mktemp -d)
          echo "delta_dir=$DELTA_DIR" >> $GITHUB_OUTPUT
          
          # Obter lista de arquivos modificados
          CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRT main origin/StepMaster)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "âš ï¸  Nenhum arquivo modificado detectado"
            exit 1
          fi
          
          # Criar estrutura de diretÃ³rios e copiar arquivos
          echo "$CHANGED_FILES" | while read -r file; do
            if [ -f "$file" ] && [[ "$file" == force-app/* ]]; then
              # Criar estrutura de diretÃ³rios
              mkdir -p "$DELTA_DIR/$(dirname "$file")"
              # Copiar arquivo
              cp "$file" "$DELTA_DIR/$file"
            fi
          done
          
          # Fazer checkout dos arquivos da branch StepMaster
          git checkout origin/StepMaster -- $CHANGED_FILES
          
          echo "ðŸ“¦ Arquivos preparados para deploy"
          echo "Total de arquivos: $(echo "$CHANGED_FILES" | wc -l)"

      - name: Executar deploy na org de ProduÃ§Ã£o
        if: steps.calculate_delta.outputs.has_changes == 'true'
        id: deploy
        continue-on-error: true
        run: |
          echo "ðŸš€ Iniciando deploy na org de produÃ§Ã£o..."
          
          # Executar deploy e capturar output
          set +e
          DEPLOY_OUTPUT=$(sf project deploy start \
            --source-dir force-app \
            --target-org prod-sync \
            --ignore-warnings \
            --wait 10 \
            --json 2>&1)
          DEPLOY_EXIT_CODE=$?
          set -e
          
          # Salvar output em arquivo
          echo "$DEPLOY_OUTPUT" > deploy-output.json
          
          # Tentar extrair JSON vÃ¡lido
          JSON_OUTPUT=$(echo "$DEPLOY_OUTPUT" | grep -o '{.*}' | tail -1 || echo "")
          
          if [ -z "$JSON_OUTPUT" ]; then
            echo "deploy_success=false" >> $GITHUB_OUTPUT
            echo "deploy_error<<EOF" >> $GITHUB_OUTPUT
            echo "Erro ao executar deploy. Output:" >> $GITHUB_OUTPUT
            echo "$DEPLOY_OUTPUT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Verificar status do deploy
          STATUS=$(echo "$JSON_OUTPUT" | jq -r '.status // 1' 2>/dev/null || echo "1")
          SUCCESS=$(echo "$JSON_OUTPUT" | jq -r '.result.success // false' 2>/dev/null || echo "false")
          
          if [ "$STATUS" = "0" ] && [ "$SUCCESS" = "true" ]; then
            echo "âœ… Deploy realizado com sucesso!"
            echo "deploy_success=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Deploy falhou"
            echo "deploy_success=false" >> $GITHUB_OUTPUT
            
            # Extrair erros
            ERROR_MESSAGES=$(echo "$JSON_OUTPUT" | jq -r '.result.details.componentFailures[]? | "\(.fileName):\(.lineNumber) - \(.problem)"' 2>/dev/null || echo "")
            
            if [ -z "$ERROR_MESSAGES" ]; then
              ERROR_MESSAGES=$(echo "$JSON_OUTPUT" | jq -r '.message // .result.message // "Erro desconhecido no deploy"' 2>/dev/null || echo "Erro desconhecido no deploy")
            fi
            
            echo "deploy_error<<EOF" >> $GITHUB_OUTPUT
            echo "$ERROR_MESSAGES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            # Salvar output completo
            echo "deploy_output<<EOF" >> $GITHUB_OUTPUT
            echo "$JSON_OUTPUT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Salvar log de erro do deploy
        if: steps.deploy.outputs.deploy_success != 'true'
        run: |
          echo "ðŸ’¾ Salvando log de erro do deploy..."
          
          # Garantir que estamos na branch main
          git checkout main
          git pull origin main || true
          
          # Criar diretÃ³rio de logs se nÃ£o existir
          mkdir -p logs/deploy-errors
          
          # Criar nome do arquivo com timestamp
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          LOG_FILE="logs/deploy-errors/deploy-error-prod-${TIMESTAMP}.log"
          
          # Obter informaÃ§Ãµes do commit
          STEP_MASTER_COMMIT=$(git rev-parse origin/StepMaster 2>/dev/null || echo "N/A")
          CHANGED_FILES=$(git diff --name-only main origin/StepMaster 2>/dev/null || echo "N/A")
          COMMITS=$(git log --oneline main..origin/StepMaster 2>/dev/null || echo "N/A")
          
          # Criar conteÃºdo do log
          cat > "$LOG_FILE" << EOF
# Log de Erro de Deploy - SincronizaÃ§Ã£o AutomÃ¡tica ProduÃ§Ã£o
# Data: $(date)
# Branch: StepMaster â†’ main
# Workflow Run: ${{ github.run_id }}
# Commit StepMaster: $STEP_MASTER_COMMIT

## Erros do Deploy

${{ steps.deploy.outputs.deploy_error }}

## Output Completo

${{ steps.deploy.outputs.deploy_output }}

## Arquivos Modificados

$CHANGED_FILES

## Commits

$COMMITS
EOF
          
          # Adicionar e commitar o log
          git add "$LOG_FILE"
          
          if git diff --staged --quiet; then
            echo "âš ï¸  Nenhuma mudanÃ§a para commitar"
          else
            git commit -m "chore: adicionar log de erro de deploy produÃ§Ã£o [skip ci]" || true
            git push origin main || echo "âš ï¸  NÃ£o foi possÃ­vel fazer push do log"
            echo "âœ… Log commitado e enviado para branch main"
          fi
          
          echo "ðŸ“„ Log salvo em: $LOG_FILE"

      - name: Fazer merge para main (se deploy foi bem-sucedido)
        if: steps.deploy.outputs.deploy_success == 'true'
        run: |
          echo "ðŸ”„ Fazendo merge de StepMaster para main..."
          
          # Garantir que estamos na branch main
          git checkout main
          git pull origin main || true
          
          # Fazer merge de StepMaster
          git merge origin/StepMaster --no-edit -m "chore: merge automÃ¡tico de StepMaster para main [skip ci]"
          
          # Push para main
          git push origin main
          
          echo "âœ… Merge realizado com sucesso!"
          echo "Branch main atualizada com as alteraÃ§Ãµes de StepMaster"

      - name: Criar resumo da execuÃ§Ã£o
        if: always()
        run: |
          echo "## ðŸ“Š Resumo da SincronizaÃ§Ã£o (ProduÃ§Ã£o)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Data/Hora**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch Origem**: StepMaster" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch Destino**: main" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.calculate_delta.outputs.has_changes }}" = "true" ]; then
            echo "- **Commits**: ${{ steps.calculate_delta.outputs.commit_count }}" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ steps.deploy.outputs.deploy_success }}" = "true" ]; then
              echo "- **Status**: âœ… Deploy realizado com sucesso e merge concluÃ­do" >> $GITHUB_STEP_SUMMARY
            else
              echo "- **Status**: âŒ Deploy falhou - log de erro salvo" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "- **Status**: â„¹ï¸  Nenhuma mudanÃ§a detectada" >> $GITHUB_STEP_SUMMARY
          fi
